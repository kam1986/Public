module Parser

open Productions
open TypeAcrobatics
open NFA
open DFA
open Position
open Token
open SLR

exception ParserError of string



/// This is a parser type, which can be invoked by manually give it a LR table, the number of states, number of symbols (terminals + nonterminals + 1) and the tuple list (production number, elements to pop, the action functions) list
/// this are generated by SLR, LR(1), LALR(1) and passed to this type
/// This is made part of the API to make hand written parser table easy to implement and test.
[<Struct>]
type Parser =
    val mutable table : Action[] // it is mutable since we need the possibility to change error handling.
    val size : int
    val symbols : int
    val actions : (int * int * (Token<int>[] -> token))[]
    new(table : Action[], size, symbols, actions) = // byref since it is faster to 'point to' than 'copy'
       { table = table ; size = size ; symbols = symbols ; actions = actions }
    
    member private P.Action state input = P.table.[state * P.size + input.GetHashCode() + 1]
    member private P.Goto state input =  P.table.[state * P.size + P.symbols + input.GetHashCode()+1]


    /// get parse table
    member P.Table = P.table
    member P.language = P.symbols
    member P.states = P.table.Length / P.size   
    /// Get or Set specific entry in the parse table.
    /// This enable to help costumize the parser explicitly, but still give the value of generation the
    /// basic parse table.
    member P.Item
        with get(state, offset) = P.table.[state * P.size + offset]
        and set(state, offset) value = P.table.[state* P.size + offset] <- value

    member P.Parse input =
        let input = 
            Seq.map (fun (token : _ Token) -> Token(token.tp.GetHashCode(), token.value, token.pos)) input
            |> fun s -> Seq.append s (seq { Token(-1, Arg null, start()) })

        let mutable stack = []
        let mutable states = [0]
        let mutable current = input
        let mutable input = Seq.head current
        let mutable NoError = true
        let mutable err = ""
        while states <> [] && NoError do
            match P.Action states.Head (TypeOf input) with
            | Shift n ->
                // this should be made alot more effecient by clever indexing of array based stack
                stack <- input :: stack
                states <- n :: states
                current <- Seq.tail current
                input <- Seq.head current

            | Reduce p ->
                // TODO!! rewrite such that the user should define the result as a Result type?
                // need to fix production
                let pops, production, action = P.actions.[p]
                let args = List.take pops stack |> List.rev |> List.toArray
                let value = 
                    try
                        action args
                    with
                        err -> 
                        
                        err.Message + " at " + (PosOf stack.[0]).ToString()
                        |> ParserError
                        |> raise

                stack <- Token(production, value, PosOf input) :: List.skip pops stack
                states <- List.skip pops states
                
                match P.Goto states.Head production with
                | Goto g ->
                    states <- g :: states

                   
                | _ -> // should never be matched
                    let pos = PosOf input
                    NoError <- false
                    err <- "Parser Error at position " + string (pos.Line, pos.Offset)
                   

            | Accept ->
                states <- []

            | _ -> 
                let pos = PosOf input
                err <- "Parser Error at position " + string (pos.Line, pos.Offset)
                printfn "states %A" states
                NoError <- false
            

        match NoError with
        | false -> 
            Result.Error (ParserError $"Parser Erro:\n {err} at {Seq.head current |> PosOf}")
        | _ ->
            try
                List.head stack 
                |> ValueOf 
                |> Ok
            with 
                | err -> Result.Error err 
                


let SLR productions = 
    productions |> SLR |> Parser

let Run (p : Parser) = p.Parse

